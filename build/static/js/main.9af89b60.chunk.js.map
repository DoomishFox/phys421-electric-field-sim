{"version":3,"sources":["FieldRenderer.js","reportWebVitals.js","SceneComponent.jsx","Particle.js","index.js"],"names":["particleMaterial","colors","lines","fieldMesh","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","onRender","rest","onSceneReady","useEffect","current","engine","Engine","scene","Scene","isReady","onReadyObservable","addOnce","runRenderLoop","render","resize","getEngine","window","addEventListener","dispose","removeEventListener","ref","Particle","mesh","charge","this","isSelected","name","position","x","y","z","createNewParticleFlag","particles","clearColor","Color4","canvas","getRenderingCanvas","gizmoManager","GizmoManager","positionGizmoEnabled","rotationGizmoEnabled","scaleGizmoEnabled","boundingBoxGizmoEnabled","camera","ArcRotateCamera","size","Vector3","setTarget","Zero","attachControl","panningSensibility","document","getElementById","addButton_Click","vecSize","bounds","Mesh","CreateLines","color","Color3","isPickable","axisSize","axisX","axisY","axisZ","createFieldLines","createFieldColors","MeshBuilder","CreateLineSystem","updatable","StandardMaterial","emissiveColor","push","createParticle","calculateMultiPointFieldLines","instance","FieldRenderer","className","SceneComponent","particleName","length","particleMesh","CreateSphere","diameter","material","count","xArray","ypos","currentYPoint","zpos","currentZPoint","xpos","currentXPoint","xPoint","lineLength","cArray","value","min","max","E","i","x_1","y_1","z_1","r_1_squared","r_1_inverse","Q_rsqrt","E_1","getFieldVector","pointer","x_m","y_m","z_m","r_m_squared","r_m_inverse","opacity","Math","cPoint","a","bytes","ArrayBuffer","Float32Array","BYTES_PER_ELEMENT","floatView","intView","Uint32Array","number","x2","k","x_0","y_0","z_0","Q","r_squared","r_inverse","ReactDOM","StrictMode","id","for","type","step"],"mappings":"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","file":"static/js/main.9af89b60.chunk.js","sourcesContent":["import React from 'react';\r\nimport { ArcRotateCamera, Color3, Color4, Vector3, Mesh, MeshBuilder, StandardMaterial, GizmoManager } from '@babylonjs/core';\r\nimport SceneComponent from './SceneComponent';\r\nimport './Field.css';\r\n\r\nimport Particle from './Particle';\r\n\r\nlet particleMaterial;\r\n\r\nlet createNewParticleFlag = false;\r\n\r\nlet particles = [];\r\n\r\nlet colors;\r\nlet lines;\r\nlet fieldMesh;\r\n\r\nconst onSceneReady = scene => {\r\n    \r\n    // ******** Scene Creation ******** //\r\n    var size = 100\r\n\r\n    //first set the scene background to be transparent\r\n    scene.clearColor = new Color4(0,0,0,0);\r\n    const canvas = scene.getEngine().getRenderingCanvas();\r\n\r\n    var gizmoManager = new GizmoManager(scene);\r\n    gizmoManager.positionGizmoEnabled = true;\r\n    gizmoManager.rotationGizmoEnabled = false;\r\n    gizmoManager.scaleGizmoEnabled = false;\r\n    gizmoManager.boundingBoxGizmoEnabled = false;\r\n\r\n    // ******** Create Camera ******** //\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    var camera = new ArcRotateCamera(\"camera1\", -0.8, 20, size + 50, new Vector3(0, 5, -10), scene);\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(Vector3.Zero());\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, true);\r\n    // set camera panning sensitivity\r\n    camera.panningSensibility = 100;\r\n\r\n\r\n    \r\n    // ******** Create GUI ******** //\r\n\r\n    var button = document.getElementById(\"add-button-id\");\r\n    button.addEventListener(\"click\", addButton_Click);\r\n    \r\n\r\n    // ******** Create Field Bounds ******** //\r\n    // You dont really need to worry about how this section works, it just creates an array of\r\n    // vectors to define the bounds cube based on the inputed size.\r\n    let vecSize = size / 2;\r\n    let bounds = Mesh.CreateLines(\"bounds\", [\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(vecSize, vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(-vecSize, -vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize)\r\n    ], scene);\r\n    bounds.color = new Color3(0.5, 0.5, 0.5);\r\n    bounds.isPickable = false;\r\n\r\n    // create an Axis to be rendered with that\r\n    // create the axis lines\r\n    let axisSize = 10;\r\n    var axisX = Mesh.CreateLines(\"axisX\", [ \r\n        new Vector3.Zero(), new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, 0.05 * axisSize, 0), \r\n        new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, -0.05 * axisSize, 0)\r\n    ], scene);\r\n    axisX.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisX.color = new Color3(1, 0, 0);\r\n    axisX.isPickable = false;\r\n    var axisY = Mesh.CreateLines(\"axisY\", [\r\n        new Vector3.Zero(), new Vector3(0, axisSize, 0), new Vector3( -0.05 * axisSize, axisSize * 0.95, 0), \r\n        new Vector3(0, axisSize, 0), new Vector3( 0.05 * axisSize, axisSize * 0.95, 0)\r\n    ], scene);\r\n    axisY.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisY.color = new Color3(0, 1, 0);\r\n    axisY.isPickable = false;\r\n    var axisZ = Mesh.CreateLines(\"axisZ\", [\r\n        new Vector3.Zero(), new Vector3(0, 0, axisSize), new Vector3( 0 , -0.05 * axisSize, axisSize * 0.95),\r\n        new Vector3(0, 0, axisSize), new Vector3( 0, 0.05 * axisSize, axisSize * 0.95)\r\n    ], scene);\r\n    axisZ.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisZ.color = new Color3(0, 0, 1);\r\n    axisZ.isPickable = false;\r\n\r\n    // ******** Create Field Lines ******** //\r\n\r\n    lines = createFieldLines(100, 10);\r\n    colors = createFieldColors(100, 10);\r\n\r\n    //let colors = array of colors\r\n    //let lines = 2 dimensional array of points\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, updatable: true }, scene)\r\n    fieldMesh.isPickable = false;\r\n\r\n    //fieldMesh.color = new Color3(1,0,0);\r\n\r\n    // ******** Create First Particle ******** //\r\n\r\n    // create material for particle mesh\r\n    particleMaterial = new StandardMaterial(\"shadelessMat\", scene);\r\n    particleMaterial.emissiveColor = new Color3(1,1,1);\r\n\r\n    particles.push(createParticle(scene, 1));\r\n}\r\n\r\n/**\r\n * Will run on every frame render. Simulation would be triggered here\r\n */\r\nconst onRender = scene => {\r\n    // first check to see if we need to create a new particle. this is a\r\n    // little ugly but the meshes need a reference to the scene and this\r\n    // seems like the best place to get that\r\n    if (createNewParticleFlag)\r\n    {\r\n        particles.push(createParticle(scene, -1));\r\n        createNewParticleFlag = false;\r\n    }\r\n\r\n    // set the charge position to be the same as the mesh representation\r\n    // charge1Position = [particleMesh.position.x, particleMesh.position.y, particleMesh.position.z];\r\n\r\n    // update the lines array with new values based on electric field equations\r\n    // calculateOnePointFieldLines(lines, charge1, charge1Position, 100, 10);\r\n    calculateMultiPointFieldLines(lines, colors, particles, 100, 10);\r\n\r\n    // pass this in with an instance of the lines mesh to update\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, instance: fieldMesh }, scene)\r\n  }\r\n\r\nfunction FieldRenderer() {\r\n    return (\r\n        <div className=\"field-container\">\r\n            <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} className='field-canvas' />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FieldRenderer;\r\n\r\n// ******** Runtime Functions ******** //\r\n\r\nvar createParticle = function(scene, charge) {\r\n    // create particle object itself\r\n    let particleName = \"particle\" + particles.length;\r\n    let particleMesh = MeshBuilder.CreateSphere(particleName, {diameter: 2}, scene, true);\r\n    particleMesh.material = particleMaterial;\r\n    particleMesh.isPickable = true;\r\n    \r\n    return new Particle(particleMesh, charge);\r\n}\r\n\r\n// ******** Button Event Handlers ******** //\r\n\r\nvar addButton_Click = function() {\r\n    createNewParticleFlag = true;\r\n}\r\n\r\n// ******** Field Line Functions ******** //\r\n\r\nconst fieldLineArrowHeight = 0.1\r\n// create the points array because im sure as heck not gonna do that by hand\r\nvar createFieldLines = function(size, count) {\r\n    let lineLength = 2;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    let xArray = [];\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Vector3(currentXPoint - (lineLength / 2), currentYPoint - (lineLength / 2), currentZPoint - (lineLength / 2)),\r\n                            new Vector3(currentXPoint, currentYPoint, currentZPoint),\r\n                            new Vector3(currentXPoint + (lineLength / 2), currentYPoint + (lineLength / 2), currentZPoint + (lineLength / 2)),\r\n                        ];\r\n\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\nvar createFieldColors = function(size, count) {\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    let xArray = [];\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n        \r\n        //var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            //var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                //var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Color4(0,0.5,1,1), new Color4(0,0.5,1,1), new Color4(1,1,1,1)];\r\n\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\n// this isnt used anymore but its still in here as a bit of a reference\r\nvar calculateOnePointFieldLines = function (xArray, charge1, charge1pos, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // first lets get x_1, y_1, and z_1\r\n                let x_1 = currentXPoint - charge1pos[0];\r\n                let y_1 = currentYPoint - charge1pos[1];\r\n                let z_1 = currentZPoint - charge1pos[2];\r\n                // next lets calculate r_1_squared\r\n                let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                // now lets calculate r_1_inverse\r\n                // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                //let r_1_inverse = 1 / Math.sqrt(r_1_squared);\r\n                // thats everything we need for calculating the field lines from charge 1!\r\n                let E = getFieldVector(x_1, y_1, z_1, charge1, r_1_squared, r_1_inverse);\r\n                // now lets scale E_1 with our linelength\r\n                E[0] = E[0] / lineLength;\r\n                E[1] = E[1] / lineLength;\r\n                E[2] = E[2] / lineLength;\r\n                // lastly we need to divide E_1 by half to center the drawn line\r\n                E[0] = E[0] / 2;\r\n                E[1] = E[1] / 2;\r\n                E[2] = E[2] / 2;\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[2].x = currentXPoint + E[0];\r\n                xPoint[2].y = currentYPoint + E[1];\r\n                xPoint[2].z = currentZPoint + E[2];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar calculateMultiPointFieldLines = function (xArray, cArray, particles, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // this is our total electric field\r\n                let E = [0, 0, 0];\r\n                // so lets add the field from all particles in view to it\r\n                for (let i = 0; i < particles.length; i++)\r\n                {\r\n                    // first lets get x_1, y_1, and z_1\r\n                    let x_1 = currentXPoint - particles[i].x;\r\n                    let y_1 = currentYPoint - particles[i].y;\r\n                    let z_1 = currentZPoint - particles[i].z;\r\n                    // next lets calculate r_1_squared\r\n                    let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                    // now lets calculate r_1_inverse\r\n                    // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                    let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                    // thats everything we need for calculating the field lines from charge 1!\r\n                    let E_1 = getFieldVector(x_1, y_1, z_1, particles[i].charge, r_1_squared, r_1_inverse);\r\n                    // now lets scale E_1 with our linelength\r\n                    E_1[0] = E_1[0] / lineLength;\r\n                    E_1[1] = E_1[1] / lineLength;\r\n                    E_1[2] = E_1[2] / lineLength;\r\n                    // lastly we need to divide E_1 by half to center the drawn line\r\n                    E_1[0] = E_1[0] / 2;\r\n                    E_1[1] = E_1[1] / 2;\r\n                    E_1[2] = E_1[2] / 2;\r\n\r\n                    // now we can combine the vectors into one so we can do that just once\r\n                    E[0] += E_1[0];\r\n                    E[1] += E_1[1];\r\n                    E[2] += E_1[2];\r\n                }\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[2].x = currentXPoint + E[0];\r\n                xPoint[2].y = currentYPoint + E[1];\r\n                xPoint[2].z = currentZPoint + E[2];\r\n\r\n                \r\n                // lets also edit the colors while we're here\r\n                // first lets get x_m, y_m, and z_m\r\n                let x_m = E[0];\r\n                let y_m = E[1];\r\n                let z_m = E[2];\r\n                // next lets calculate r_m_squared\r\n                let r_m_squared = (x_m * x_m) + (y_m * y_m) + (z_m * z_m);\r\n                // now lets calculate r_m_inverse is 1 / sqrt(r_m_squared)\r\n                let r_m_inverse = Q_rsqrt(r_m_squared);\r\n                // using that lets get the final magnitude of the vector\r\n                let E_m = r_m_squared * r_m_inverse;\r\n                // then we clamp that vector between 0.1 and 1 so we can\r\n                // use it for opacity\r\n                let opacity = clamp(E_m, 0.1, 1);\r\n\r\n                let cPoint = cArray[pointer];\r\n\r\n                cPoint[0].a = opacity;\r\n                cPoint[1].a = opacity;\r\n                cPoint[2].a = opacity;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// So this was taken from someone much smarter than I on stackoverflow that\r\n// implemented the fast inverse square root method used in quake iii.\r\n// it is absolutely disgusting and abuses computers in ways I never thought\r\n// possible before. I love it.\r\n// The inline comments from the original programmer and the quake iii source\r\n// has been preserved because there is no better way to describe what is\r\n// happening here.\r\nconst bytes = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT);\r\nconst floatView = new Float32Array(bytes);\r\nconst intView = new Uint32Array(bytes);\r\nconst threehalfs = 1.5;\r\nfunction Q_rsqrt(number) {\r\n    const x2 = number * 0.5;\r\n    floatView[0] = number;                              // evil floating point bit level hacking\r\n    intView[0] = 0x5f3759df - ( intView[0] >> 1 );      // What the fuck?\r\n    let y = floatView[0];\r\n    y = y * ( threehalfs - ( x2 * y * y ) );            // 1st iteration\r\n//\ty  = y * ( threehalfs - ( x2 * y * y ) );           // 2nd iteration, this can be removed\r\n    return y;\r\n}\r\n\r\n// I managed to condense the equation for the components of an electric\r\n// field down to these. No trig, the only tricky but is a square root\r\n// but because its divided by that we can use the fast inverse square root\r\n// method and just multiply instead!\r\nconst k = 8987742438;\r\nfunction getFieldVector(x_0, y_0, z_0, Q, r_squared, r_inverse) {\r\n    let E_y = (k) * (y_0 * Q * r_inverse) / (r_squared);\r\n    let E_z = (k) * (z_0 * Q * r_inverse) / (r_squared);\r\n    let E_x = (k) * (x_0 * Q * r_inverse) / (r_squared);\r\n    return [E_x, E_y, E_z];\r\n}\r\n\r\nfunction clamp(value, min, max) {\r\n    return Math.max(min, Math.min(value, max));\r\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { Engine, Scene } from '@babylonjs/core'\r\nimport React, { useEffect, useRef } from 'react'\r\nexport default (props) => {\r\n    const reactCanvas = useRef(null);\r\n    const { antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onRender, onSceneReady, ...rest } = props;\r\n    useEffect(() => {\r\n        if (reactCanvas.current) {\r\n            const engine = new Engine(reactCanvas.current, antialias, engineOptions, adaptToDeviceRatio);\r\n            const scene = new Scene(engine, sceneOptions);\r\n            if (scene.isReady()) {\r\n                props.onSceneReady(scene)\r\n            } else {\r\n                scene.onReadyObservable.addOnce(scene => props.onSceneReady(scene));\r\n            }\r\n            engine.runRenderLoop(() => {\r\n                if (typeof onRender === 'function') {\r\n                    onRender(scene);\r\n                }\r\n                scene.render();\r\n            })\r\n            const resize = () => {\r\n                scene.getEngine().resize();\r\n            }\r\n            if (window) {\r\n                window.addEventListener('resize', resize);\r\n            }\r\n            return () => {\r\n                scene.getEngine().dispose();\r\n                if (window) {\r\n                    window.removeEventListener('resize', resize);\r\n                }\r\n            }\r\n        }\r\n    }, [reactCanvas])\r\n    return (\r\n        <canvas ref={reactCanvas} {...rest} />\r\n    );\r\n}","class Particle {\r\n    constructor(mesh, charge) {\r\n        this.mesh = mesh;\r\n        this.charge = charge;\r\n        this.isSelected = false;\r\n    }\r\n\r\n    get name() {\r\n        return this.mesh.name;\r\n    }\r\n\r\n    get x() {\r\n        return this.mesh.position.x;\r\n    }\r\n\r\n    get y() {\r\n        return this.mesh.position.y;\r\n    }\r\n\r\n    get z() {\r\n        return this.mesh.position.z;\r\n    }\r\n}\r\n\r\nexport default Particle;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport FieldRenderer from './FieldRenderer';\n\nReactDOM.render(\n  <React.StrictMode>\n    <FieldRenderer />\n    <div id=\"ui-static\" className=\"ui-static-container\">\n      <button id=\"add-button-id\" className=\"add-button\">New Particle</button>\n    </div>\n    <div id=\"ui-dynamic\" className=\"ui-dynamic-container\">\n      <label id=\"dynamic-label-id\" className=\"dynamic-label\" for=\"charge-id\">Charge: </label>\n      <a >charge value</a>\n      <br/>\n      <input type=\"range\" id=\"charge-id\" className=\"charge\" name=\"charge\" min=\"-2\" max=\"2\" step=\"0.1\"/>\n    </div>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}