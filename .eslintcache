[{"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\index.js":"1","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\FieldRenderer.js":"2","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\reportWebVitals.js":"3","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\Particle.js":"4","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\SceneComponent.jsx":"5"},{"size":1030,"mtime":1607572710883,"results":"6","hashOfConfig":"7"},{"size":18315,"mtime":1607574476893,"results":"8","hashOfConfig":"7"},{"size":375,"mtime":1607549434669,"results":"9","hashOfConfig":"7"},{"size":442,"mtime":1607571590441,"results":"10","hashOfConfig":"7"},{"size":1423,"mtime":1607549434668,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14","usedDeprecatedRules":"15"},"1a9n9yn",{"filePath":"16","messages":"17","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18","usedDeprecatedRules":"15"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"26"},"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\index.js",["27","28"],"import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport FieldRenderer from './FieldRenderer';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <FieldRenderer />\r\n    <div id=\"ui-static\" className=\"ui-static-container\">\r\n      <button id=\"add-button-id\" className=\"add-button\">New Particle</button>\r\n    </div>\r\n    <div id=\"ui-dynamic\" className=\"ui-dynamic-container\">\r\n      <label className=\"dynamic-label\" htmlFor=\"charge-id\">Charge: </label>\r\n      <a id=\"dynamic-label-id\">charge value</a>\r\n      <a > C</a>\r\n      <br/>\r\n      <input type=\"range\" id=\"charge-id\" className=\"charge\" name=\"charge\" min=\"-2\" max=\"2\" step=\"0.1\"/>\r\n    </div>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n",["29","30"],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\FieldRenderer.js",["31","32","33","34","35"],"import React from 'react';\r\nimport { ArcRotateCamera, Color3, Color4, Vector3, Mesh, MeshBuilder, StandardMaterial, GizmoManager } from '@babylonjs/core';\r\nimport SceneComponent from './SceneComponent';\r\nimport './Field.css';\r\n\r\nimport Particle from './Particle';\r\n\r\nlet camera;\r\n\r\nlet particleUI;\r\nlet chargeDisplay;\r\nlet chargeSlider;\r\n\r\nlet particleMaterial;\r\n\r\nlet createNewParticleFlag = false;\r\n\r\nlet selectedParticle;\r\nlet particles = [];\r\n\r\nlet colors;\r\nlet lines;\r\nlet fieldMesh;\r\n\r\nconst onSceneReady = scene => {\r\n    \r\n    // ******** Scene Creation ******** //\r\n    var size = 100\r\n\r\n    //first set the scene background to be transparent\r\n    scene.clearColor = new Color4(0,0,0,0);\r\n    const canvas = scene.getEngine().getRenderingCanvas();\r\n\r\n    var gizmoManager = new GizmoManager(scene);\r\n    gizmoManager.positionGizmoEnabled = true;\r\n    gizmoManager.rotationGizmoEnabled = false;\r\n    gizmoManager.scaleGizmoEnabled = false;\r\n    gizmoManager.boundingBoxGizmoEnabled = false;\r\n\r\n    // ******** Create Camera ******** //\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    camera = new ArcRotateCamera(\"camera1\", -0.8, 20, size + 50, new Vector3(0, 5, -10), scene);\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(Vector3.Zero());\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, true);\r\n    // set camera panning sensitivity\r\n    camera.panningSensibility = 100;\r\n\r\n\r\n    \r\n    // ******** Create GUI ******** //\r\n\r\n    var button = document.getElementById(\"add-button-id\");\r\n    button.addEventListener(\"click\", addButton_Click);\r\n\r\n    particleUI = document.getElementById(\"ui-dynamic\");\r\n    particleUI.style.display = \"none\";\r\n\r\n    chargeDisplay = document.getElementById(\"dynamic-label-id\");\r\n    chargeDisplay.textContent = \"0\";\r\n\r\n    chargeSlider = document.getElementById(\"charge-id\");\r\n    chargeSlider.addEventListener(\"input\", chargeSliderChange);\r\n\r\n    scene.onPointerPick = onPointerPick;\r\n    \r\n\r\n    // ******** Create Field Bounds ******** //\r\n    // You dont really need to worry about how this section works, it just creates an array of\r\n    // vectors to define the bounds cube based on the inputed size.\r\n    let vecSize = size / 2;\r\n    let bounds = Mesh.CreateLines(\"bounds\", [\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(vecSize, vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(-vecSize, -vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize)\r\n    ], scene);\r\n    bounds.color = new Color3(0.5, 0.5, 0.5);\r\n    bounds.isPickable = false;\r\n\r\n    // create an Axis to be rendered with that\r\n    // create the axis lines\r\n    let axisSize = 10;\r\n    var axisX = Mesh.CreateLines(\"axisX\", [ \r\n        new Vector3.Zero(), new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, 0.05 * axisSize, 0), \r\n        new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, -0.05 * axisSize, 0)\r\n    ], scene);\r\n    axisX.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisX.color = new Color3(1, 0, 0);\r\n    axisX.isPickable = false;\r\n    var axisY = Mesh.CreateLines(\"axisY\", [\r\n        new Vector3.Zero(), new Vector3(0, axisSize, 0), new Vector3( -0.05 * axisSize, axisSize * 0.95, 0), \r\n        new Vector3(0, axisSize, 0), new Vector3( 0.05 * axisSize, axisSize * 0.95, 0)\r\n    ], scene);\r\n    axisY.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisY.color = new Color3(0, 1, 0);\r\n    axisY.isPickable = false;\r\n    var axisZ = Mesh.CreateLines(\"axisZ\", [\r\n        new Vector3.Zero(), new Vector3(0, 0, axisSize), new Vector3( 0 , -0.05 * axisSize, axisSize * 0.95),\r\n        new Vector3(0, 0, axisSize), new Vector3( 0, 0.05 * axisSize, axisSize * 0.95)\r\n    ], scene);\r\n    axisZ.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisZ.color = new Color3(0, 0, 1);\r\n    axisZ.isPickable = false;\r\n\r\n    // ******** Create Field Lines ******** //\r\n\r\n    lines = createFieldLines(100, 10);\r\n    colors = createFieldColors(100, 10);\r\n\r\n    //let colors = array of colors\r\n    //let lines = 2 dimensional array of points\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, updatable: true }, scene)\r\n    fieldMesh.isPickable = false;\r\n\r\n    //fieldMesh.color = new Color3(1,0,0);\r\n\r\n    // ******** Create First Particle ******** //\r\n\r\n    // create material for particle mesh\r\n    particleMaterial = new StandardMaterial(\"shadelessMat\", scene);\r\n    particleMaterial.emissiveColor = new Color3(1,1,1);\r\n\r\n    particles.push(createParticle(scene, 1));\r\n}\r\n\r\n/**\r\n * Will run on every frame render. Simulation would be triggered here\r\n */\r\nconst onRender = scene => {\r\n    // first check to see if we need to create a new particle. this is a\r\n    // little ugly but the meshes need a reference to the scene and this\r\n    // seems like the best place to get that\r\n    if (createNewParticleFlag)\r\n    {\r\n        particles.push(createParticle(scene, -1));\r\n        createNewParticleFlag = false;\r\n    }\r\n\r\n    // set the charge position to be the same as the mesh representation\r\n    // charge1Position = [particleMesh.position.x, particleMesh.position.y, particleMesh.position.z];\r\n\r\n    // update the lines array with new values based on electric field equations\r\n    // calculateOnePointFieldLines(lines, charge1, charge1Position, 100, 10);\r\n    calculateMultiPointFieldLines(lines, colors, particles, 100, 10);\r\n\r\n    // pass this in with an instance of the lines mesh to update\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, instance: fieldMesh }, scene)\r\n  }\r\n\r\nfunction FieldRenderer() {\r\n    return (\r\n        <div className=\"field-container\">\r\n            <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} className='field-canvas' />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FieldRenderer;\r\n\r\n// ******** Runtime Functions ******** //\r\n\r\nvar onPointerPick = function(pointerEvent, pickInfo) {\r\n    console.log(\"Picked \" + pickInfo.pickedMesh.name);\r\n\r\n    // show the particle UI\r\n    particleUI.style.display = \"block\";\r\n\r\n    // lets get our particle object based on the mesh name\r\n    selectedParticle = particles.filter( (particle) => particle.name == pickInfo.pickedMesh.name)[0];\r\n\r\n    //console.log(selectedParticle);\r\n\r\n    chargeDisplay.textContent = selectedParticle.charge;\r\n    chargeSlider.value = selectedParticle.charge;\r\n}\r\n\r\nvar createParticle = function(scene, charge) {\r\n    // create particle object itself\r\n    let particleName = \"particle\" + particles.length;\r\n    let particleMesh = MeshBuilder.CreateSphere(particleName, {diameter: 2}, scene, true);\r\n    particleMesh.material = particleMaterial;\r\n    particleMesh.isPickable = true;\r\n    \r\n    return new Particle(particleMesh, charge);\r\n}\r\n\r\n// ******** Event Handlers ******** //\r\n\r\nvar addButton_Click = function() {\r\n    createNewParticleFlag = true;\r\n}\r\n\r\nvar chargeSliderChange = function() {\r\n    selectedParticle.charge = chargeSlider.value;\r\n    chargeDisplay.textContent = chargeSlider.value;\r\n}\r\n\r\n// ******** Field Line Functions ******** //\r\n\r\nconst fieldLineArrowHeight = 0.1\r\n// create the points array because im sure as heck not gonna do that by hand\r\nvar createFieldLines = function(size, count) {\r\n    let lineLength = 2;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    let xArray = [];\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Vector3(currentXPoint - (lineLength / 2), currentYPoint - (lineLength / 2), currentZPoint - (lineLength / 2)),\r\n                            new Vector3(currentXPoint, currentYPoint, currentZPoint),\r\n                            new Vector3(currentXPoint + (lineLength / 2), currentYPoint + (lineLength / 2), currentZPoint + (lineLength / 2)),\r\n                        ];\r\n\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\nvar createFieldColors = function(size, count) {\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    let xArray = [];\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n        \r\n        //var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            //var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                //var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Color4(0,0.5,1,1), new Color4(0,0.5,1,1), new Color4(1,1,1,1)];\r\n\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\n// this isnt used anymore but its still in here as a bit of a reference\r\nvar calculateOnePointFieldLines = function (xArray, charge1, charge1pos, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // first lets get x_1, y_1, and z_1\r\n                let x_1 = currentXPoint - charge1pos[0];\r\n                let y_1 = currentYPoint - charge1pos[1];\r\n                let z_1 = currentZPoint - charge1pos[2];\r\n                // next lets calculate r_1_squared\r\n                let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                // now lets calculate r_1_inverse\r\n                // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                //let r_1_inverse = 1 / Math.sqrt(r_1_squared);\r\n                // thats everything we need for calculating the field lines from charge 1!\r\n                let E = getFieldVector(x_1, y_1, z_1, charge1, r_1_squared, r_1_inverse);\r\n                // now lets scale E_1 with our linelength\r\n                E[0] = E[0] / lineLength;\r\n                E[1] = E[1] / lineLength;\r\n                E[2] = E[2] / lineLength;\r\n                // lastly we need to divide E_1 by half to center the drawn line\r\n                E[0] = E[0] / 2;\r\n                E[1] = E[1] / 2;\r\n                E[2] = E[2] / 2;\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[2].x = currentXPoint + E[0];\r\n                xPoint[2].y = currentYPoint + E[1];\r\n                xPoint[2].z = currentZPoint + E[2];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar calculateMultiPointFieldLines = function (xArray, cArray, particles, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (let ypos = 0; ypos < count; ypos++) {\r\n\r\n        let currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (let zpos = 0; zpos < count; zpos++) {\r\n\r\n            let currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (let xpos = 0; xpos < count; xpos++) {\r\n\r\n                let currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // this is our total electric field\r\n                let E = [0, 0, 0];\r\n                // so lets add the field from all particles in view to it\r\n                for (let i = 0; i < particles.length; i++)\r\n                {\r\n                    // first lets get x_1, y_1, and z_1\r\n                    let x_1 = currentXPoint - particles[i].x;\r\n                    let y_1 = currentYPoint - particles[i].y;\r\n                    let z_1 = currentZPoint - particles[i].z;\r\n                    // next lets calculate r_1_squared\r\n                    let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                    // now lets calculate r_1_inverse\r\n                    // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                    let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                    // thats everything we need for calculating the field lines from charge 1!\r\n                    let E_1 = getFieldVector(x_1, y_1, z_1, particles[i].charge, r_1_squared, r_1_inverse);\r\n                    // now lets scale E_1 with our linelength\r\n                    E_1[0] = E_1[0] / lineLength;\r\n                    E_1[1] = E_1[1] / lineLength;\r\n                    E_1[2] = E_1[2] / lineLength;\r\n                    // lastly we need to divide E_1 by half to center the drawn line\r\n                    E_1[0] = E_1[0] / 2;\r\n                    E_1[1] = E_1[1] / 2;\r\n                    E_1[2] = E_1[2] / 2;\r\n\r\n                    // now we can combine the vectors into one so we can do that just once\r\n                    E[0] += E_1[0];\r\n                    E[1] += E_1[1];\r\n                    E[2] += E_1[2];\r\n                }\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                let pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[2].x = currentXPoint + E[0];\r\n                xPoint[2].y = currentYPoint + E[1];\r\n                xPoint[2].z = currentZPoint + E[2];\r\n\r\n                \r\n                // lets also edit the colors while we're here\r\n                // first lets get x_m, y_m, and z_m\r\n                let x_m = E[0];\r\n                let y_m = E[1];\r\n                let z_m = E[2];\r\n                // next lets calculate r_m_squared\r\n                let r_m_squared = (x_m * x_m) + (y_m * y_m) + (z_m * z_m);\r\n                // now lets calculate r_m_inverse is 1 / sqrt(r_m_squared)\r\n                let r_m_inverse = Q_rsqrt(r_m_squared);\r\n                // using that lets get the final magnitude of the vector\r\n                let E_m = r_m_squared * r_m_inverse;\r\n                // then we clamp that vector between 0.1 and 1 so we can\r\n                // use it for opacity\r\n                let opacity = clamp(E_m, 0.1, 1);\r\n\r\n                let cPoint = cArray[pointer];\r\n\r\n                cPoint[0].a = opacity;\r\n                cPoint[1].a = opacity;\r\n                cPoint[2].a = opacity;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// So this was taken from someone much smarter than I on stackoverflow that\r\n// implemented the fast inverse square root method used in quake iii.\r\n// it is absolutely disgusting and abuses computers in ways I never thought\r\n// possible before. I love it.\r\n// The inline comments from the original programmer and the quake iii source\r\n// has been preserved because there is no better way to describe what is\r\n// happening here.\r\nconst bytes = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT);\r\nconst floatView = new Float32Array(bytes);\r\nconst intView = new Uint32Array(bytes);\r\nconst threehalfs = 1.5;\r\nfunction Q_rsqrt(number) {\r\n    const x2 = number * 0.5;\r\n    floatView[0] = number;                              // evil floating point bit level hacking\r\n    intView[0] = 0x5f3759df - ( intView[0] >> 1 );      // What the fuck?\r\n    let y = floatView[0];\r\n    y = y * ( threehalfs - ( x2 * y * y ) );            // 1st iteration\r\n//\ty  = y * ( threehalfs - ( x2 * y * y ) );           // 2nd iteration, this can be removed\r\n    return y;\r\n}\r\n\r\n// I managed to condense the equation for the components of an electric\r\n// field down to these. No trig, the only tricky but is a square root\r\n// but because its divided by that we can use the fast inverse square root\r\n// method and just multiply instead!\r\nconst k = 8987742438;\r\nfunction getFieldVector(x_0, y_0, z_0, Q, r_squared, r_inverse) {\r\n    let E_y = (k) * (y_0 * Q * r_inverse) / (r_squared);\r\n    let E_z = (k) * (z_0 * Q * r_inverse) / (r_squared);\r\n    let E_x = (k) * (x_0 * Q * r_inverse) / (r_squared);\r\n    return [E_x, E_y, E_z];\r\n}\r\n\r\nfunction clamp(value, min, max) {\r\n    return Math.max(min, Math.min(value, max));\r\n}","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\reportWebVitals.js",[],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\Particle.js",[],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\phys421-electric-field-sim\\src\\SceneComponent.jsx",["36","37"],"import { Engine, Scene } from '@babylonjs/core'\r\nimport React, { useEffect, useRef } from 'react'\r\nexport default (props) => {\r\n    const reactCanvas = useRef(null);\r\n    const { antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onRender, onSceneReady, ...rest } = props;\r\n    useEffect(() => {\r\n        if (reactCanvas.current) {\r\n            const engine = new Engine(reactCanvas.current, antialias, engineOptions, adaptToDeviceRatio);\r\n            const scene = new Scene(engine, sceneOptions);\r\n            if (scene.isReady()) {\r\n                props.onSceneReady(scene)\r\n            } else {\r\n                scene.onReadyObservable.addOnce(scene => props.onSceneReady(scene));\r\n            }\r\n            engine.runRenderLoop(() => {\r\n                if (typeof onRender === 'function') {\r\n                    onRender(scene);\r\n                }\r\n                scene.render();\r\n            })\r\n            const resize = () => {\r\n                scene.getEngine().resize();\r\n            }\r\n            if (window) {\r\n                window.addEventListener('resize', resize);\r\n            }\r\n            return () => {\r\n                scene.getEngine().dispose();\r\n                if (window) {\r\n                    window.removeEventListener('resize', resize);\r\n                }\r\n            }\r\n        }\r\n    }, [reactCanvas])\r\n    return (\r\n        <canvas ref={reactCanvas} {...rest} />\r\n    );\r\n}",["38","39"],{"ruleId":"40","severity":1,"message":"41","line":15,"column":7,"nodeType":"42","endLine":15,"endColumn":32},{"ruleId":"40","severity":1,"message":"41","line":16,"column":7,"nodeType":"42","endLine":16,"endColumn":11},{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":179,"column":70,"nodeType":"49","messageId":"50","endLine":179,"endColumn":72},{"ruleId":"51","severity":1,"message":"52","line":210,"column":7,"nodeType":"53","messageId":"54","endLine":210,"endColumn":27},{"ruleId":"51","severity":1,"message":"55","line":271,"column":5,"nodeType":"53","messageId":"54","endLine":271,"endColumn":32},{"ruleId":"51","severity":1,"message":"56","line":273,"column":11,"nodeType":"53","messageId":"54","endLine":273,"endColumn":24},{"ruleId":"51","severity":1,"message":"56","line":328,"column":11,"nodeType":"53","messageId":"54","endLine":328,"endColumn":24},{"ruleId":"57","severity":1,"message":"58","line":3,"column":1,"nodeType":"59","endLine":38,"endColumn":2},{"ruleId":"60","severity":1,"message":"61","line":34,"column":8,"nodeType":"62","endLine":34,"endColumn":21,"suggestions":"63"},{"ruleId":"43","replacedBy":"64"},{"ruleId":"45","replacedBy":"65"},"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-native-reassign",["66"],"no-negated-in-lhs",["67"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'fieldLineArrowHeight' is assigned a value but never used.","Identifier","unusedVar","'calculateOnePointFieldLines' is assigned a value but never used.","'maxLineLength' is assigned a value but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'adaptToDeviceRatio', 'antialias', 'engineOptions', 'onRender', 'props', and 'sceneOptions'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["68"],["66"],["67"],"no-global-assign","no-unsafe-negation",{"desc":"69","fix":"70"},"Update the dependencies array to be: [adaptToDeviceRatio, antialias, engineOptions, onRender, props, reactCanvas, sceneOptions]",{"range":"71","text":"72"},[1336,1349],"[adaptToDeviceRatio, antialias, engineOptions, onRender, props, reactCanvas, sceneOptions]"]