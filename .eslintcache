[{"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\index.js":"1","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\reportWebVitals.js":"2","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\SceneComponent.jsx":"3","C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\FieldRenderer.js":"4"},{"size":530,"mtime":1606973096094,"results":"5","hashOfConfig":"6"},{"size":362,"mtime":499162500000,"results":"7","hashOfConfig":"6"},{"size":1423,"mtime":1606800453289,"results":"8","hashOfConfig":"6"},{"size":15921,"mtime":1607078911877,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"ec5ndw",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"18"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"12"},"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\index.js",[],["22","23"],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\reportWebVitals.js",[],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\SceneComponent.jsx",["24","25"],"import { Engine, Scene } from '@babylonjs/core'\r\nimport React, { useEffect, useRef } from 'react'\r\nexport default (props) => {\r\n    const reactCanvas = useRef(null);\r\n    const { antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onRender, onSceneReady, ...rest } = props;\r\n    useEffect(() => {\r\n        if (reactCanvas.current) {\r\n            const engine = new Engine(reactCanvas.current, antialias, engineOptions, adaptToDeviceRatio);\r\n            const scene = new Scene(engine, sceneOptions);\r\n            if (scene.isReady()) {\r\n                props.onSceneReady(scene)\r\n            } else {\r\n                scene.onReadyObservable.addOnce(scene => props.onSceneReady(scene));\r\n            }\r\n            engine.runRenderLoop(() => {\r\n                if (typeof onRender === 'function') {\r\n                    onRender(scene);\r\n                }\r\n                scene.render();\r\n            })\r\n            const resize = () => {\r\n                scene.getEngine().resize();\r\n            }\r\n            if (window) {\r\n                window.addEventListener('resize', resize);\r\n            }\r\n            return () => {\r\n                scene.getEngine().dispose();\r\n                if (window) {\r\n                    window.removeEventListener('resize', resize);\r\n                }\r\n            }\r\n        }\r\n    }, [reactCanvas])\r\n    return (\r\n        <canvas ref={reactCanvas} {...rest} />\r\n    );\r\n}",["26","27"],"C:\\home\\Workspace\\College\\Semester 3\\PHYS421\\Project\\react test\\mag-app\\src\\FieldRenderer.js",["28","29","30","31","32","33","34","35","36"],"import React from 'react';\r\nimport { ArcRotateCamera, Color3, Color4, Vector3, Mesh, MeshBuilder, StandardMaterial, PointerEventTypes, GizmoManager } from '@babylonjs/core';\r\nimport SceneComponent from './SceneComponent';\r\nimport './Field.css';\r\n\r\nlet particleMesh;\r\n\r\nlet charge1Position;\r\nlet charge1 = 1;\r\n\r\nlet colors;\r\nlet lines;\r\nlet fieldMesh;\r\n\r\nconst onSceneReady = scene => {\r\n    \r\n    // ******** Scene Creation ******** //\r\n    var size = 100\r\n\r\n    //first set the scene background to be transparent\r\n    scene.clearColor = new Color4(0,0,0,0);\r\n    const canvas = scene.getEngine().getRenderingCanvas();\r\n\r\n    var gizmoManager = new GizmoManager(scene);\r\n    gizmoManager.positionGizmoEnabled = true;\r\n    gizmoManager.rotationGizmoEnabled = false;\r\n    gizmoManager.scaleGizmoEnabled = false;\r\n    gizmoManager.boundingBoxGizmoEnabled = false;\r\n\r\n    // ******** Create Camera ******** //\r\n\r\n    // This creates and positions a free camera (non-mesh)\r\n    var camera = new ArcRotateCamera(\"camera1\", -0.8, 20, size + 50, new Vector3(0, 5, -10), scene);\r\n    // This targets the camera to scene origin\r\n    camera.setTarget(Vector3.Zero());\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, true);\r\n    // set camera panning sensitivity\r\n    camera.panningSensibility = 100;\r\n\r\n    \r\n\r\n    // ******** Create Field Bounds ******** //\r\n    // You dont really need to worry about how this section works, it just creates an array of\r\n    // vectors to define the bounds cube based on the inputed size.\r\n    var vecSize = size / 2;\r\n    var bounds = Mesh.CreateLines(\"bounds\", [\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(vecSize, vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, vecSize),\r\n        new Vector3(-vecSize, -vecSize, vecSize), new Vector3(-vecSize, -vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize), new Vector3(vecSize, -vecSize, -vecSize),\r\n        new Vector3(vecSize, vecSize, -vecSize), new Vector3(-vecSize, vecSize, -vecSize),\r\n        new Vector3(-vecSize, -vecSize, -vecSize)\r\n    ], scene);\r\n    bounds.color = new Color3(0.5, 0.5, 0.5);\r\n    bounds.isPickable = false;\r\n\r\n    // create an Axis to be rendered with that\r\n    // create the axis lines\r\n    var axisSize = 10;\r\n    var axisX = Mesh.CreateLines(\"axisX\", [ \r\n        new Vector3.Zero(), new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, 0.05 * axisSize, 0), \r\n        new Vector3(axisSize, 0, 0), new Vector3(axisSize * 0.95, -0.05 * axisSize, 0)\r\n    ], scene);\r\n    axisX.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisX.color = new Color3(1, 0, 0);\r\n    axisX.isPickable = false;\r\n    var axisY = Mesh.CreateLines(\"axisY\", [\r\n        new Vector3.Zero(), new Vector3(0, axisSize, 0), new Vector3( -0.05 * axisSize, axisSize * 0.95, 0), \r\n        new Vector3(0, axisSize, 0), new Vector3( 0.05 * axisSize, axisSize * 0.95, 0)\r\n    ], scene);\r\n    axisY.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisY.color = new Color3(0, 1, 0);\r\n    axisY.isPickable = false;\r\n    var axisZ = Mesh.CreateLines(\"axisZ\", [\r\n        new Vector3.Zero(), new Vector3(0, 0, axisSize), new Vector3( 0 , -0.05 * axisSize, axisSize * 0.95),\r\n        new Vector3(0, 0, axisSize), new Vector3( 0, 0.05 * axisSize, axisSize * 0.95)\r\n    ], scene);\r\n    axisZ.position = new Vector3(-vecSize - 2, -vecSize - 2, -vecSize - 2);\r\n    axisZ.color = new Color3(0, 0, 1);\r\n    axisZ.isPickable = false;\r\n\r\n    // ******** Create Field Lines ******** //\r\n\r\n    lines = createFieldLines(100, 10);\r\n    colors = createFieldColors(100, 10);\r\n\r\n    //let colors = array of colors\r\n    //let lines = 2 dimensional array of points\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, updatable: true }, scene)\r\n    fieldMesh.isPickable = false;\r\n\r\n    //fieldMesh.color = new Color3(1,0,0);\r\n\r\n    // ******** Create First Particle ******** //\r\n\r\n    // create material for particle mesh\r\n    var shadelessMat = new StandardMaterial(\"shadelessMat\", scene);\r\n    shadelessMat.emissiveColor = new Color3(1,1,1);\r\n\r\n    // create particle object itself\r\n    //var particle = Mesh.CreateSphere('particle', 32, 2, scene);\r\n    particleMesh = MeshBuilder.CreateSphere('particleBox', {diameter: 2}, scene, true);\r\n    particleMesh.material = shadelessMat;\r\n    particleMesh.isPickable = true;\r\n}\r\n\r\n/**\r\n * Will run on every frame render. Simulation would be triggered here\r\n */\r\nconst onRender = scene => {\r\n    // set the charge position to be the same as the mesh representation\r\n    charge1Position = [particleMesh.position.x, particleMesh.position.y, particleMesh.position.z];\r\n\r\n    // update the lines array with new values based on electric field equations\r\n    calculateOnePointFieldLines(lines, charge1, charge1Position, 100, 10);\r\n\r\n    // pass this in with an instance of the lines mesh to update\r\n    fieldMesh = MeshBuilder.CreateLineSystem(\"fieldLines\",\r\n        { colors: colors, lines: lines, instance: fieldMesh }, scene)\r\n  }\r\n\r\nfunction FieldRenderer() {\r\n    return (\r\n        <div className=\"field-container\">\r\n            <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} className='field-canvas' />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FieldRenderer;\r\n\r\n// create the points array because im sure as heck not gonna do that by hand\r\nvar createFieldLines = function(size, count) {\r\n    var lineLength = 2;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    var xArray = new Array();\r\n\r\n    for (var ypos = 0; ypos < count; ypos++) {\r\n\r\n        var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (var zpos = 0; zpos < count; zpos++) {\r\n\r\n            var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (var xpos = 0; xpos < count; xpos++) {\r\n\r\n                var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Vector3(currentXPoint - (lineLength / 2), currentYPoint - (lineLength / 2), currentZPoint - (lineLength / 2)),\r\n                            new Vector3(currentXPoint, currentYPoint, currentZPoint),\r\n                            new Vector3(currentXPoint, currentYPoint, currentZPoint),\r\n                            new Vector3(currentXPoint + (lineLength / 2), currentYPoint + (lineLength / 2), currentZPoint + (lineLength / 2))];\r\n\r\n                var pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\nvar createFieldColors = function(size, count) {\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n    var xArray = new Array();\r\n\r\n    for (var ypos = 0; ypos < count; ypos++) {\r\n        \r\n        var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (var zpos = 0; zpos < count; zpos++) {\r\n\r\n            var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (var xpos = 0; xpos < count; xpos++) {\r\n\r\n                var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                let xPoint = [new Color4(1,1,1,0.5), new Color4(1,1,1,0.5),\r\n                new Color4(1,0,0,0.5), new Color4(1,0,0,0.5)];\r\n\r\n                var pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                xArray[pointer] = xPoint;\r\n            }\r\n        }\r\n    }\r\n    return xArray;\r\n}\r\n\r\nvar calculateOnePointFieldLines = function (xArray, charge1, charge1pos, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (var ypos = 0; ypos < count; ypos++) {\r\n\r\n        var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (var zpos = 0; zpos < count; zpos++) {\r\n\r\n            var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (var xpos = 0; xpos < count; xpos++) {\r\n\r\n                var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // first lets get x_1, y_1, and z_1\r\n                let x_1 = currentXPoint - charge1pos[0];\r\n                let y_1 = currentYPoint - charge1pos[1];\r\n                let z_1 = currentZPoint - charge1pos[2];\r\n                // next lets calculate r_1_squared\r\n                let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                // now lets calculate r_1_inverse\r\n                // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                //let r_1_inverse = 1 / Math.sqrt(r_1_squared);\r\n                // thats everything we need for calculating the field lines from charge 1!\r\n                let E = getFieldVector(x_1, y_1, z_1, charge1, r_1_squared, r_1_inverse);\r\n                // now lets scale E_1 with our linelength\r\n                E[0] = E[0] / lineLength;\r\n                E[1] = E[1] / lineLength;\r\n                E[2] = E[2] / lineLength;\r\n                // lastly we need to divide E_1 by half to center the drawn line\r\n                E[0] = E[0] / 2;\r\n                E[1] = E[1] / 2;\r\n                E[2] = E[2] / 2;\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                var pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[3].x = currentXPoint + E[0];\r\n                xPoint[3].y = currentYPoint + E[1];\r\n                xPoint[3].z = currentZPoint + E[2];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar calculateTwoPointFieldLines = function (xArray, charge1, charge1pos, charge2, charge2pos, size, count) {\r\n    const lineLength = 10000000;\r\n    const maxLineLength = 4;\r\n    // ok so we need to create count^3, but lets do this logically\r\n    // lets start with across the X axis\r\n\r\n    for (var ypos = 0; ypos < count; ypos++) {\r\n\r\n        var currentYPoint = (ypos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n        for (var zpos = 0; zpos < count; zpos++) {\r\n\r\n            var currentZPoint = (zpos * (size / count)) + ((size / count) / 2) -(size / 2);\r\n\r\n            for (var xpos = 0; xpos < count; xpos++) {\r\n\r\n                var currentXPoint = (xpos * (size / count)) + ((size / count) / 2) - (size / 2);\r\n\r\n                // first lets get x_1, y_1, and z_1\r\n                let x_1 = currentXPoint - charge1pos[0];\r\n                let y_1 = currentYPoint - charge1pos[1];\r\n                let z_1 = currentZPoint - charge1pos[2];\r\n                // next lets calculate r_1_squared\r\n                let r_1_squared = (x_1 * x_1) + (y_1 * y_1) + (z_1 * z_1);\r\n                // now lets calculate r_1_inverse\r\n                // r_1_inverse is 1 / sqrt(r_squared) for which we will use the black magic of Q_rsqrt()\r\n                let r_1_inverse = Q_rsqrt(r_1_squared);\r\n                // thats everything we need for calculating the field lines from charge 1!\r\n                let E_1 = getFieldVector(x_1, y_1, z_1, charge1, r_1_squared, r_1_inverse);\r\n                // now lets scale E_1 with our linelength\r\n                E_1[0] = E_1[0] / lineLength;\r\n                E_1[1] = E_1[1] / lineLength;\r\n                E_1[2] = E_1[2] / lineLength;\r\n                // lastly we need to divide E_1 by half to center the drawn line\r\n                E_1[0] = E_1[0] / 2;\r\n                E_1[1] = E_1[1] / 2;\r\n                E_1[2] = E_1[2] / 2;\r\n\r\n                // now lets do that all over again for E_2\r\n                // first x_1, y_1, and z_1\r\n                let x_2 = currentXPoint - charge2pos[0];\r\n                let y_2 = currentYPoint - charge2pos[1];\r\n                let z_2 = currentZPoint - charge2pos[2];\r\n                // next r_2_squared\r\n                let r_2_squared = (x_2 * x_2) + (y_2 * y_2) + (z_2 * z_2);\r\n                // now for r_2_inverse\r\n                let r_2_inverse = Q_rsqrt(r_2_squared);\r\n                // and finally we can get E_2\r\n                let E_2 = getFieldVector(x_2, y_2, z_2, charge2, r_2_squared, r_2_inverse);\r\n                // we need to scale E_2 to match the scaling on E_1\r\n                E_2[0] = E_2[0] / lineLength;\r\n                E_2[1] = E_2[1] / lineLength;\r\n                E_2[2] = E_2[2] / lineLength;\r\n                // lastly we need to divide E_1 by half to center the drawn line\r\n                E_2[0] = E_2[0] / 2;\r\n                E_2[1] = E_2[1] / 2;\r\n                E_2[2] = E_2[2] / 2;\r\n\r\n                // now we can combine the vectors into one so we can do that just once\r\n                let E = [\r\n                    E_1[0] + E_2[0],\r\n                    E_1[1] + E_2[1],\r\n                    E_1[2] + E_2[2]\r\n                ];\r\n\r\n                // now we have vector components of both fields!\r\n                // lets sum them together in our array\r\n                var pointer = (ypos * count * count) + (zpos * count) + xpos;\r\n                let xPoint = xArray[pointer];\r\n\r\n                xPoint[0].x = currentXPoint - E[0];\r\n                xPoint[0].y = currentYPoint - E[1];\r\n                xPoint[0].z = currentZPoint - E[2];\r\n                xPoint[3].x = currentXPoint + E[0];\r\n                xPoint[3].y = currentYPoint + E[1];\r\n                xPoint[3].z = currentZPoint + E[2];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// So this was taken from someone much smarter than I on stackoverflow that\r\n// implemented the fast inverse square root method used in quake iii.\r\n// it is absolutely disgusting and abuses computers in ways I never thought\r\n// possible before. I love it.\r\n// The inline comments from the original programmer and the quake iii source\r\n// has been preserved because there is no better way to describe what is\r\n// happening here.\r\nconst bytes = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT);\r\nconst floatView = new Float32Array(bytes);\r\nconst intView = new Uint32Array(bytes);\r\nconst threehalfs = 1.5;\r\nfunction Q_rsqrt(number) {\r\n    const x2 = number * 0.5;\r\n    floatView[0] = number;                              // evil floating point bit level hacking\r\n    intView[0] = 0x5f3759df - ( intView[0] >> 1 );      // What the fuck?\r\n    let y = floatView[0];\r\n    y = y * ( threehalfs - ( x2 * y * y ) );            // 1st iteration\r\n//\ty  = y * ( threehalfs - ( x2 * y * y ) );           // 2nd iteration, this can be removed\r\n    return y;\r\n}\r\n\r\n// I managed to condense the equation for the components of an electric\r\n// field down to these. No trig, the only tricky but is a square root\r\n// but because its divided by that we can use the fast inverse square root\r\n// method and just multiply instead!\r\nconst k = 8987742438;\r\nfunction getFieldVector(x_0, y_0, z_0, Q, r_squared, r_inverse) {\r\n    let E_y = (k) * (y_0 * Q * r_inverse) / (r_squared);\r\n    let E_z = (k) * (z_0 * Q * r_inverse) / (r_squared);\r\n    let E_x = (k) * (x_0 * Q * r_inverse) / (r_squared);\r\n    return [E_x, E_y, E_z];\r\n}",{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":3,"column":1,"nodeType":"43","endLine":38,"endColumn":2},{"ruleId":"44","severity":1,"message":"45","line":34,"column":8,"nodeType":"46","endLine":34,"endColumn":21,"suggestions":"47"},{"ruleId":"37","replacedBy":"48"},{"ruleId":"39","replacedBy":"49"},{"ruleId":"50","severity":1,"message":"51","line":2,"column":89,"nodeType":"52","messageId":"53","endLine":2,"endColumn":106},{"ruleId":"54","severity":1,"message":"55","line":142,"column":18,"nodeType":"56","messageId":"57","endLine":142,"endColumn":29},{"ruleId":"54","severity":1,"message":"55","line":172,"column":18,"nodeType":"56","messageId":"57","endLine":172,"endColumn":29},{"ruleId":"50","severity":1,"message":"58","line":176,"column":13,"nodeType":"52","messageId":"53","endLine":176,"endColumn":26},{"ruleId":"50","severity":1,"message":"59","line":180,"column":17,"nodeType":"52","messageId":"53","endLine":180,"endColumn":30},{"ruleId":"50","severity":1,"message":"60","line":184,"column":21,"nodeType":"52","messageId":"53","endLine":184,"endColumn":34},{"ruleId":"50","severity":1,"message":"61","line":199,"column":11,"nodeType":"52","messageId":"53","endLine":199,"endColumn":24},{"ruleId":"50","severity":1,"message":"62","line":252,"column":5,"nodeType":"52","messageId":"53","endLine":252,"endColumn":32},{"ruleId":"50","severity":1,"message":"61","line":254,"column":11,"nodeType":"52","messageId":"53","endLine":254,"endColumn":24},"no-native-reassign",["63"],"no-negated-in-lhs",["64"],"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'adaptToDeviceRatio', 'antialias', 'engineOptions', 'onRender', 'props', and 'sceneOptions'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["65"],["63"],["64"],"no-unused-vars","'PointerEventTypes' is defined but never used.","Identifier","unusedVar","no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","'currentYPoint' is assigned a value but never used.","'currentZPoint' is assigned a value but never used.","'currentXPoint' is assigned a value but never used.","'maxLineLength' is assigned a value but never used.","'calculateTwoPointFieldLines' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"66","fix":"67"},"Update the dependencies array to be: [adaptToDeviceRatio, antialias, engineOptions, onRender, props, reactCanvas, sceneOptions]",{"range":"68","text":"69"},[1336,1349],"[adaptToDeviceRatio, antialias, engineOptions, onRender, props, reactCanvas, sceneOptions]"]